<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>OOP Round Track Racing</title>
<style>
  body {
    background:#111;
    display:flex;
    justify-content:center;
    align-items:center;
    height:100vh;
    margin:0;
    font-family:sans-serif;
  }
  canvas {
    background:#222;
    border:4px solid #fff;
  }
  #ui {
    position:absolute;
    top:20px;
    color:white;
    font-size:24px;
    text-shadow:0 0 6px black;
  }
  #startScreen, #endScreen {
    position:absolute;
    inset:0;
    background:rgba(0,0,0,0.8);
    display:flex;
    flex-direction:column;
    justify-content:center;
    align-items:center;
    color:white;
    font-size:32px;
  }
  button {
    margin-top:20px;
    padding:10px 20px;
    font-size:20px;
    cursor:pointer;
  }
</style>
</head>
<body>

<div id="ui">Lap: <span id="lap">0</span> / 3</div>

<div id="startScreen">
  <div>Round Track Racer</div>
  <button id="startBtn">Start Race</button>
</div>

<div id="endScreen" style="display:none;">
  <div id="endText"></div>
  <button id="restartBtn">Restart</button>
</div>

<canvas id="game" width="800" height="800"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const lapDisplay = document.getElementById("lap");

const keys = {};
document.addEventListener("keydown", e => keys[e.key] = true);
document.addEventListener("keyup", e => keys[e.key] = false);

const TRACK_RADIUS = 250;
const TRACK_WIDTH = 140;
const FINISH_X1 = 400 - 20;
const FINISH_X2 = 400 + 20;
const FINISH_Y1 = 400 - TRACK_RADIUS - TRACK_WIDTH/2;
const FINISH_Y2 = 400 - TRACK_RADIUS + TRACK_WIDTH/2;
const LAP_COUNT = 3;
// Waypoints around the circular track
const waypoints = [];
const WP_COUNT = 32; // more = smoother path

for (let i = 0; i < WP_COUNT; i++) {
  const a = (Math.PI * 2 / WP_COUNT) * i;
  waypoints.push({
    x: 400 + Math.sin(a) * TRACK_RADIUS,
    y: 400 - Math.cos(a) * TRACK_RADIUS
  });
}
let gameRunning = false;

// ----------------------------
// CAR CLASS
// ----------------------------
class Car {
  constructor(x, y, angle, color, isPlayer=false) {
    this.x = x;
    this.y = y;
    this.angle = angle;
    this.speed = 0;
    this.color = color;
    this.isPlayer = isPlayer;

    this.maxSpeed = isPlayer ? 4 : 3;
    this.accel = isPlayer ? 0.12 : 0.08;
    this.turnSpeed = isPlayer ? 0.035 : 0.02;

    this.lap = 0;
    this.prevAngle = angle;
  }

  update(dt) {
    if (this.isPlayer) this.updatePlayer(dt);
    else this.updateAI(dt);

    this.checkLap();
  }

  updatePlayer(dt) {
    if (keys["ArrowUp"]) this.speed += this.accel;
    if (keys["ArrowDown"]) this.speed -= this.accel;

    // friction
    if (!keys["ArrowUp"] && !keys["ArrowDown"]) {
      this.speed *= 0.98;
    }

    // clamp
    this.speed = Math.max(Math.min(this.speed, this.maxSpeed), -1);

    // turning
    if (keys["ArrowLeft"]) this.angle -= this.turnSpeed * (this.speed / this.maxSpeed);
    if (keys["ArrowRight"]) this.angle += this.turnSpeed * (this.speed / this.maxSpeed);

    // movement
    this.x += Math.sin(this.angle) * this.speed;
    this.y -= Math.cos(this.angle) * this.speed;

    this.keepOnTrack();
  }

  updateAI() {
  for (const ai of aiCars) {

    // Get current waypoint
    const wp = waypoints[ai.wp];

    // Direction vector toward waypoint
    const dx = wp.x - ai.x;
    const dy = wp.y - ai.y;

    // Desired angle
    const targetAngle = Math.atan2(dx, -dy);

    // Angle difference
    let diff = targetAngle - ai.angle;
    diff = (diff + Math.PI * 3) % (Math.PI * 2) - Math.PI;

    // Turn toward waypoint
    ai.angle += diff * 0.05; // steering strength

    // Move forward
    ai.speed = ai.maxSpeed * 0.6;
    ai.x += Math.sin(ai.angle) * ai.speed;
    ai.y -= Math.cos(ai.angle) * ai.speed;

    // Advance waypoint when close
    const dist = Math.hypot(dx, dy);
    if (dist < 40) {
      ai.wp = (ai.wp + 1) % waypoints.length;
    }

    // AI faces forward
    ai.angleDraw = ai.angle;

// Lap detection (safe version)
const angleNow = (Math.atan2(ai.x - 400, 400 - ai.y) + Math.PI * 2) % (Math.PI * 2);

// Only count a lap if the AI is MOVING FORWARD through the finish line
const crossedStart =
  ai.prevAngle < Math.PI && angleNow >= Math.PI * 1.99; // approaching from below

if (crossedStart) {
  ai.lap++;
  if (ai.lap >= LAP_COUNT) endRace("AI wins!");
}

ai.prevAngle = angleNow;


    // Collision with player
    const pdx = ai.x - player.x;
    const pdy = ai.y - player.y;
    if (Math.abs(pdx) < 30 && Math.abs(pdy) < 50) {
      player.speed = 0;
      ctx.fillStyle = "red";
      ctx.font = "40px sans-serif";
      ctx.fillText("CRASH!", 330, 400);
    }
  }
}

  keepOnTrack() {
    const dx = this.x - 400;
    const dy = this.y - 400;
    const dist = Math.sqrt(dx*dx + dy*dy);

    if (dist < TRACK_RADIUS - TRACK_WIDTH/2 || dist > TRACK_RADIUS + TRACK_WIDTH/2) {
      this.speed = 0;
    }
  }

  checkLap() {
  // Check if car is inside finish line zone
  const inside =
    this.x > FINISH_X1 &&
    this.x < FINISH_X2 &&
    this.y > FINISH_Y1 &&
    this.y < FINISH_Y2;

  // Only count a lap when entering the zone from outside
  if (inside && !this.wasInsideFinish) {
    this.lap++;

    if (this.isPlayer) {
      lapDisplay.textContent = this.lap;
    }

    if (this.lap >= LAP_COUNT) {
      endRace(this.isPlayer ? "You win!" : "AI wins!");
    }
  }

  this.wasInsideFinish = inside;
}

  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    ctx.fillStyle = this.color;
    ctx.fillRect(-15, -30, 30, 60);
    ctx.restore();
  }
}

// ----------------------------
// TRACK
// ----------------------------
function drawTrack() {
  ctx.save();
  ctx.translate(400, 400);

  // Outer circle
  ctx.beginPath();
  ctx.strokeStyle = "#555";
  ctx.lineWidth = TRACK_WIDTH;
  ctx.arc(0, 0, TRACK_RADIUS, 0, Math.PI*2);
  ctx.stroke();

  // Center dashed line
  ctx.beginPath();
  ctx.strokeStyle = "#fff";
  ctx.lineWidth = 4;
  ctx.setLineDash([20, 20]);
  ctx.arc(0, 0, TRACK_RADIUS, 0, Math.PI*2);
  ctx.stroke();
// FINISH LINE (vertical, full width)
ctx.setLineDash([]);
ctx.fillStyle = "white";

// vertical bar across the road
ctx.fillRect(
  -6,                     // x offset (centered)
  -TRACK_RADIUS - TRACK_WIDTH/2,  // top of road
  12,                     // thickness
  TRACK_WIDTH             // height (full road width)
);


  ctx.restore();
}

// ----------------------------
// GAME SETUP
// ----------------------------
let player;
let aiCars = [];

function startGame() {
  document.getElementById("startScreen").style.display = "none";
  document.getElementById("endScreen").style.display = "none";
player = new Car(
  400,
  400 - TRACK_RADIUS + TRACK_WIDTH * 0.25, // moved further up
  Math.PI / 2,
  "red",
  true
);


aiCars = [];
for (let i = 0; i < 4; i++) {

  // AI start 40px behind the player, spread horizontally
  const offsetAngle = Math.PI / 2 + 0.15 + i * 0.15; 
  const r = TRACK_RADIUS - TRACK_WIDTH * 0.25;

  const ai = new Car(
    400 + Math.sin(offsetAngle) * r,
    400 - Math.cos(offsetAngle) * r,
    offsetAngle,
    "#0af",
    false
  );

  // Stagger waypoint targets so they don't clump
  ai.wp = Math.floor((waypoints.length / 4) * i);

  // Prevent instant lap triggers
  ai.prevAngle = offsetAngle;
  ai.lap = 0;
  ai.wasInsideFinish = false;

  aiCars.push(ai);
}



  lapDisplay.textContent = "0";
  gameRunning = true;
  lastTime = performance.now();
  loop();
}

function endRace(text) {
  gameRunning = false;
  document.getElementById("endText").textContent = text;
  document.getElementById("endScreen").style.display = "flex";
}

// ----------------------------
// MAIN LOOP
// ----------------------------
let lastTime = 0;

function loop(timestamp) {
  if (!gameRunning) return;

  const dt = (timestamp - lastTime) / 16.666;
  lastTime = timestamp;

  ctx.clearRect(0,0,800,800);

  drawTrack();

  player.update(dt);
  player.draw();

  for (const ai of aiCars) {
    ai.update(dt);
    ai.draw();
  }

  requestAnimationFrame(loop);
}

// ----------------------------
// UI BUTTONS
// ----------------------------
document.getElementById("startBtn").onclick = startGame;
document.getElementById("restartBtn").onclick = startGame;

</script>
</body>
</html>